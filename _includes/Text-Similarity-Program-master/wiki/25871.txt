Code refactoring is the process of restructuring existing computer code – changing the factoring – without changing its external behavior  Refactoring improves nonfunctional attributes of the software  Advantages include improved code readability and reduced complexity to improve source code maintainability  and create a more expressive internal architecture or object model to improve extensibility   Typically  refactoring applies a series of standardised basic micro refactorings  each of which is  usually  a tiny change in a computer program s source code that either preserves the behaviour of the software  or at least does not modify its conformance to functional requirements  Many development environments provide automated support for performing the mechanical aspects of these basic refactorings   1  Overview  Refactoring is usually motivated by noticing a code smell  For example the method at hand may be very long  or it may be a near duplicate of another nearby method  Once recognized  such problems can be addressed by refactoring the source code  or transforming it into a new form that behaves the same as before but that no longer  smells   For a long routine  one or more smaller subroutines can be extracted  or for duplicate routines  the duplication can be removed and replaced with one shared function  Failure to perform refactoring can result in accumulating technical debt   There are two general categories of benefits to the activity of refactoring   Maintainability  It is easier to fix bugs because the source code is easy to read and the intent of its author is easy to grasp  This might be achieved by reducing large monolithic routines into a set of individually concise  well named  single purpose methods  It might be achieved by moving a method to a more appropriate class  or by removing misleading comments   Extensibility  It is easier to extend the capabilities of the application if it uses recognizable design patterns  and it provides some flexibility where none before may have existed  Before applying a refactoring to a section of code  a solid set of automatic unit tests is needed  The tests are used to demonstrate that the behavior of the module is correct before the refactoring  If it inadvertently turns out that a test fails  then it s generally best to fix the test first  because otherwise it is hard to distinguish between failures introduced by refactoring and failures that were already there  After the refactoring  the tests are run again to verify the refactoring didn t break the tests  Of course  the tests can never prove that there are no bugs  but the important point is that this process can be cost effective  good unit tests can catch enough errors to make them worthwhile and to make refactoring safe enough   The process is then an iterative cycle of making a small program transformation  testing it to ensure correctness  and making another small transformation  If at any point a test fails  the last small change is undone and repeated in a different way  Through many small steps the program moves from where it was to where you want it to be  For this very iterative process to be practical  the tests must run very quickly  or the programmer would have to spend a large fraction of his or her time waiting for the tests to finish  Proponents of extreme programming and other agile software development describe this activity as an integral part of the software development cycle   2  List of refactoring techniques  Here are some examples of micro refactorings  some of these may only apply to certain languages or language types  A longer list can be found in Fowler s Refactoring book and on Fowler s Refactoring Website  Many development environments provide automated support for these micro refactorings  For instance  a programmer could click on the name of a variable and then select the  Encapsulate field  refactoring from a context menu  The IDE would then prompt for additional details  typically with sensible defaults and a preview of the code changes  After confirmation by the programmer it would carry out the required changes throughout the code   Techniques that allow for more abstraction  Encapsulate Field – force code to access the field with getter and setter methods  Generalize Type – create more general types to allow for more code sharing  Replace type checking code with State Strategy  Replace conditional with polymorphism  Techniques for breaking code apart into more logical pieces  Componentization breaks code down into reusable semantic units that present clear  well defined  simple to use interfaces   Extract Class moves part of the code from an existing class into a new class   Extract Method  to turn part of a larger method into a new method  By breaking down code in smaller pieces  it is more easily understandable  This is also applicable to functions   Techniques for improving names and location of code  Move Method or Move Field – move to a more appropriate Class or source file  Rename Method or Rename Field – changing the name into a new one that better reveals its purpose  Pull Up – in OOP  move to a superclass  Push Down – in OOP  move to a subclass  3  Hardware refactoring  While the term refactoring originally referred exclusively to refactoring of software code  in recent years code written in hardware description languages  HDLs  has also been refactored  The term hardware refactoring is used as a shorthand term for refactoring of code in hardware description languages  Since HDLs are not considered to be programming languages by most hardware engineers  hardware refactoring is to be considered a separate field from traditional code refactoring   Automated refactoring of analog hardware descriptions  in VHDL AMS  has been proposed by Zeng and Huss  In their approach  refactoring preserves the simulated behavior of a hardware design  The non functional measurement that improves is that refactored code can be processed by standard synthesis tools  while the original code cannot  Refactoring of digital HDLs  albeit manual refactoring  has also been investigated by Synopsys fellow Mike Keating  His target is to make complex systems easier to understand  which increases the designers  productivity   In the summer of 2008  there was an intense discussion about refactoring of VHDL code on the news   comp lang vhdl newsgroup  The discussion revolved around a specific manual refactoring performed by one engineer  and the question to whether or not automated tools for such refactoring exist   As of late 2009  Sigasi is offering automated tool support for VHDL refactoring   AMIQ DVT  an IDE for hardware design and verification  provides refactoring capabilities for e  verification language   SystemVerilog  Verilog and VHDL   4  History  Although refactoring code has been done informally for years  William Griswold s 1991 Ph D  dissertation is one of the first major academic works on refactoring functional and procedural programs  followed by William Opdyke s 1992 dissertation on the refactoring of object oriented programs  although all the theory and machinery have long been available as program transformation systems  All of these resources provide a catalog of common methods for refactoring  a refactoring method has a description of how to apply the method and indicators for when you should  or should not  apply the method   Martin Fowler s book Refactoring  Improving the Design of Existing Code is the canonical reference   The first known use of the term  refactoring  in the published literature was in a September  1990 article by William Opdyke and Ralph Johnson  Griswold s Ph D  thesis  Opdyke s Ph D  thesis  published in 1992  also used this term   The term  factoring  has been used in the Forth community since at least the early 1980s  Chapter Six of Leo Brodie s book Thinking Forth  1984  is dedicated to the subject   In extreme programming  the Extract Method refactoring technique has essentially the same meaning as factoring in Forth  to break down a  word   or function  into smaller  more easily maintained functions   Refactorings can also be reconstructed posthoc to produce concise descriptions of complex software changes recorded in software repositories like CVS or SVN   5  Automated code refactoring  Many software editors and IDEs have automated refactoring support  Here is a list of a few of these editors  or so called refactoring browsers   IntelliJ IDEA  for Java   WebStorm  for JavaScript   Eclipse  for Java  and to a lesser extent  C++  PHP  Ruby and JavaScript   NetBeans  for Java   JDeveloper  for Java   Embarcadero Delphi  Visual Studio  for  NET   ReSharper  addon for Visual Studio   CodeRush  addon for Visual Studio   Visual Assist  addon for Visual Studio with refactoring support for C# and C++   DMS Software Reengineering Toolkit  Implements large scale refactoring for C  C++  C#  COBOL  Java  PHP and other languages   Photran  a Fortran plugin for the Eclipse IDE   SharpSort addin for Visual Studio 2008  Sigasi HDT  for VHDL   Xcode  for C  Objective C  and Swift   AppCode  for Objective C  C and C++   Smalltalk Refactoring Browser  for Smalltalk   Simplifide  for Verilog  VHDL and SystemVerilog   Tidier  for Erlang   AMIQ DVT  for e  SystemVerilog  Verilog and VHDL   Bicycle Repair Man   for Python   6  See also  Code review  Database refactoring  Decomposition  computer science   Design pattern  computer science   Obfuscated code  Software peer review  Prefactoring  Separation of concerns  Test driven development  Modular programming  7  References  8  Further reading  Mens  Tom and Tourwé  Tom  2004    IEEE Transactions on Software Engineering  February 2004  vol  30 no  2   pp  126–139  9  External links   c2 com article   by Ramnivas Laddad  by Tom Mens and Tom Tourwé   a refactoring pattern not listed in the above catalog 